####  Libraries ----------------------------------------------------------------
####
library(mvtnorm)
library(plyr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(zoo)
####
####  Annual Plant Model Functions ---------------------------------------------
####
### Update seedbank function
updateN <- function(g, s, alpha, lambda, lastN){
newN <- numeric(2)
for(i in 1:2){
newN[i] <- lastN[i]*s[i]*(1-g[i]) + ((lambda[i]*g[i]*lastN[i]) / (1 + (alpha[i]*g[i]*lastN[i] + alpha[-i]*g[-i]*lastN[-i])))
if(newN < 1) { newN <- 0 }
}
return(newN)
}
### Get germination fractions function
getG <- function(sigE, rho, nTime){
varcov <- matrix(c(sigE, rho*sigE, rho*sigE, sigE), 2, 2)
e      <- rmvnorm(n = nTime, mean = c(0,0), sigma = varcov)
g      <- exp(e) / (1+exp(e))
return(g)
}
####
#### Simulations ---------------------------------------------------------------
####
par(mfrow=c(1,3), mgp=c(2.2,0.45,0), tcl=-0.4, mar=c(3.3,3.6,1.1,1.1), las=1)
### Low variability // competitive exclusion
gSeries <- getG(sigE[1], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(100,100)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Competitive Exclusion")
totpop1 <- rowSums(N)
### High variability // coexistence
gSeries <- getG(sigE[2], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(100,100)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Species Coexistence")
totpop2 <- rowSums(N)
### Plot the rolling CV
mycv <- function(x) {sd(x) / mean(x)}
rolling_cv <- data.frame(cv1 = rollapply(totpop1, width=10, FUN=mycv, fill=NA),
cv2 = rollapply(totpop2, width=10, FUN=mycv, fill=NA),
iteration = 1:length(totpop1))
matplot(rolling_cv[,c(1:2)], type="l", col=c("grey45","steelblue"), bty="n")
##  Two Species Annual Plant Population Model: simulates the dynamics of
##  the seedbanks of two competing annual plants. The plants coxist by the
##  storage effect. This is just to show two time series (one with coexistence,
##  one with exclusion) and to show that reducing environmental variability
##  causes exclusion and a reduction in ecosystem stability, here measured by
##  total community abundance.
##
##  Author:       Andrew Tredennick (atredenn@gmail.com)
##  Date created: November 11, 2016
rm(list=ls(all.names = TRUE))
####
#### Parameters ----------------------------------------------------------------
####
sigE   <- c(0.05,0.5)
rho    <- c(0.5,0,-0.5)
s      <- c(0.5, 0.5)
alpha  <- c(1,1)
lambda <- c(101,99)
nTime  <- 2000
####
####  Libraries ----------------------------------------------------------------
####
library(mvtnorm)
library(plyr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(zoo)
####
####  Annual Plant Model Functions ---------------------------------------------
####
### Update seedbank function
updateN <- function(g, s, alpha, lambda, lastN){
newN <- numeric(2)
for(i in 1:2){
newN[i] <- lastN[i]*s[i]*(1-g[i]) + ((lambda[i]*g[i]*lastN[i]) / (1 + (alpha[i]*g[i]*lastN[i] + alpha[-i]*g[-i]*lastN[-i])))
if(newN < 1) { newN <- 0 }
}
return(newN)
}
### Get germination fractions function
getG <- function(sigE, rho, nTime){
varcov <- matrix(c(sigE, rho*sigE, rho*sigE, sigE), 2, 2)
e      <- rmvnorm(n = nTime, mean = c(0,0), sigma = varcov)
g      <- exp(e) / (1+exp(e))
return(g)
}
####
#### Simulations ---------------------------------------------------------------
####
par(mfrow=c(1,3), mgp=c(2.2,0.45,0), tcl=-0.4, mar=c(3.3,3.6,1.1,1.1), las=1)
### Low variability // competitive exclusion
gSeries <- getG(sigE[1], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(100,100)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Competitive Exclusion")
totpop1 <- rowSums(N)
### High variability // coexistence
gSeries <- getG(sigE[2], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(100,100)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Species Coexistence")
totpop2 <- rowSums(N)
### Plot the rolling CV
mycv <- function(x) {sd(x) / mean(x)}
rolling_cv <- data.frame(cv1 = rollapply(totpop1, width=10, FUN=mycv, fill=NA),
cv2 = rollapply(totpop2, width=10, FUN=mycv, fill=NA),
iteration = 1:length(totpop1))
matplot(rolling_cv[,c(1:2)], type="l", col=c("grey45","steelblue"), bty="n")
##  Two Species Annual Plant Population Model: simulates the dynamics of
##  the seedbanks of two competing annual plants. The plants coxist by the
##  storage effect. This is just to show two time series (one with coexistence,
##  one with exclusion) and to show that reducing environmental variability
##  causes exclusion and a reduction in ecosystem stability, here measured by
##  total community abundance.
##
##  Author:       Andrew Tredennick (atredenn@gmail.com)
##  Date created: November 11, 2016
rm(list=ls(all.names = TRUE))
####
#### Parameters ----------------------------------------------------------------
####
sigE   <- c(0.05,0.5)
rho    <- c(0.5,0,-0.5)
s      <- c(0.5, 0.5)
alpha  <- c(1,1)
lambda <- c(101,99)
nTime  <- 2000
####
####  Libraries ----------------------------------------------------------------
####
library(mvtnorm)
library(plyr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(zoo)
####
####  Annual Plant Model Functions ---------------------------------------------
####
### Update seedbank function
updateN <- function(g, s, alpha, lambda, lastN){
newN <- numeric(2)
for(i in 1:2){
newN[i] <- lastN[i]*s[i]*(1-g[i]) + ((lambda[i]*g[i]*lastN[i]) / (1 + (alpha[i]*g[i]*lastN[i] + alpha[-i]*g[-i]*lastN[-i])))
if(newN < 1) { newN <- 0 }
}
return(newN)
}
### Get germination fractions function
getG <- function(sigE, rho, nTime){
varcov <- matrix(c(sigE, rho*sigE, rho*sigE, sigE), 2, 2)
e      <- rmvnorm(n = nTime, mean = c(0,0), sigma = varcov)
g      <- exp(e) / (1+exp(e))
return(g)
}
####
#### Simulations ---------------------------------------------------------------
####
par(mfrow=c(1,3), mgp=c(2.2,0.45,0), tcl=-0.4, mar=c(3.3,3.6,1.1,1.1), las=1)
### Low variability // competitive exclusion
gSeries <- getG(sigE[1], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(10,10)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Competitive Exclusion")
totpop1 <- rowSums(N)
### High variability // coexistence
gSeries <- getG(sigE[2], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(10,10)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Species Coexistence")
totpop2 <- rowSums(N)
### Plot the rolling CV
mycv <- function(x) {sd(x) / mean(x)}
rolling_cv <- data.frame(cv1 = rollapply(totpop1, width=10, FUN=mycv, fill=NA),
cv2 = rollapply(totpop2, width=10, FUN=mycv, fill=NA),
iteration = 1:length(totpop1))
matplot(rolling_cv[,c(1:2)], type="l", col=c("grey45","steelblue"), bty="n")
##  Two Species Annual Plant Population Model: simulates the dynamics of
##  the seedbanks of two competing annual plants. The plants coxist by the
##  storage effect. This is just to show two time series (one with coexistence,
##  one with exclusion) and to show that reducing environmental variability
##  causes exclusion and a reduction in ecosystem stability, here measured by
##  total community abundance.
##
##  Author:       Andrew Tredennick (atredenn@gmail.com)
##  Date created: November 11, 2016
rm(list=ls(all.names = TRUE))
####
#### Parameters ----------------------------------------------------------------
####
sigE   <- c(0.05,0.5)
rho    <- c(0.5,0,-0.5)
s      <- c(0.5, 0.5)
alpha  <- c(1,1)
lambda <- c(101,99)
nTime  <- 2000
####
####  Libraries ----------------------------------------------------------------
####
library(mvtnorm)
library(plyr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(zoo)
####
####  Annual Plant Model Functions ---------------------------------------------
####
### Update seedbank function
updateN <- function(g, s, alpha, lambda, lastN){
newN <- numeric(2)
for(i in 1:2){
newN[i] <- lastN[i]*s[i]*(1-g[i]) + ((lambda[i]*g[i]*lastN[i]) / (1 + (alpha[i]*g[i]*lastN[i] + alpha[-i]*g[-i]*lastN[-i])))
if(newN < 1) { newN <- 0 }
}
return(newN)
}
### Get germination fractions function
getG <- function(sigE, rho, nTime){
varcov <- matrix(c(sigE, rho*sigE, rho*sigE, sigE), 2, 2)
e      <- rmvnorm(n = nTime, mean = c(0,0), sigma = varcov)
g      <- exp(e) / (1+exp(e))
return(g)
}
####
#### Simulations ---------------------------------------------------------------
####
par(mfrow=c(1,3), mgp=c(2.2,0.45,0), tcl=-0.4, mar=c(3.3,3.6,1.1,1.1), las=1)
### Low variability // competitive exclusion
gSeries <- getG(sigE[1], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(10,10)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Competitive Exclusion")
totpop1 <- rowSums(N)
### High variability // coexistence
gSeries <- getG(sigE[2], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(10,10)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Species Coexistence")
totpop2 <- rowSums(N)
### Plot the rolling CV
mycv <- function(x) {sd(x) / mean(x)}
rolling_cv <- data.frame(cv1 = rollapply(totpop1, width=10, FUN=mycv, fill=NA),
cv2 = rollapply(totpop2, width=10, FUN=mycv, fill=NA),
iteration = 1:length(totpop1))
matplot(rolling_cv[,c(1:2)], type="l", col=c("grey45","steelblue"), bty="n")
##  Two Species Annual Plant Population Model: simulates the dynamics of
##  the seedbanks of two competing annual plants. The plants coxist by the
##  storage effect. This is just to show two time series (one with coexistence,
##  one with exclusion) and to show that reducing environmental variability
##  causes exclusion and a reduction in ecosystem stability, here measured by
##  total community abundance.
##
##  Author:       Andrew Tredennick (atredenn@gmail.com)
##  Date created: November 11, 2016
rm(list=ls(all.names = TRUE))
####
#### Parameters ----------------------------------------------------------------
####
sigE   <- c(0.05,0.5)
rho    <- c(0.5,0,-0.5)
s      <- c(0.5, 0.5)
alpha  <- c(1,1)
lambda <- c(101,99)
nTime  <- 2000
####
####  Libraries ----------------------------------------------------------------
####
library(mvtnorm)
library(plyr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(zoo)
####
####  Annual Plant Model Functions ---------------------------------------------
####
### Update seedbank function
updateN <- function(g, s, alpha, lambda, lastN){
newN <- numeric(2)
for(i in 1:2){
newN[i] <- lastN[i]*s[i]*(1-g[i]) + ((lambda[i]*g[i]*lastN[i]) / (1 + (alpha[i]*g[i]*lastN[i] + alpha[-i]*g[-i]*lastN[-i])))
if(newN < 1) { newN <- 0 }
}
return(newN)
}
### Get germination fractions function
getG <- function(sigE, rho, nTime){
varcov <- matrix(c(sigE, rho*sigE, rho*sigE, sigE), 2, 2)
e      <- rmvnorm(n = nTime, mean = c(0,0), sigma = varcov)
g      <- exp(e) / (1+exp(e))
return(g)
}
####
#### Simulations ---------------------------------------------------------------
####
par(mfrow=c(1,3), mgp=c(2.2,0.45,0), tcl=-0.4, mar=c(3.3,3.6,1.1,1.1), las=1)
### Low variability // competitive exclusion
gSeries <- getG(sigE[1], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(10,10)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Competitive Exclusion")
totpop1 <- rowSums(N)
### High variability // coexistence
gSeries <- getG(sigE[2], rho[2], nTime)
N       <- matrix(data = NA, nrow = nTime, ncol = 2)
N[1,]   <- c(10,10)
for(t in 2:nTime){
N[t,] <- updateN(g=gSeries[t,], s, alpha, lambda, lastN=N[t-1,])
}
matplot(c(1:nTime), N, type="l", lwd=1, lty=1, bty="n", xlab="Time",
ylab="Population Size (N)", main="Species Coexistence")
totpop2 <- rowSums(N)
### Plot the rolling CV
mycv <- function(x) {sd(x) / mean(x)}
rolling_cv <- data.frame(cv1 = rollapply(totpop1, width=10, FUN=mycv, fill=NA),
cv2 = rollapply(totpop2, width=10, FUN=mycv, fill=NA),
iteration = 1:length(totpop1))
matplot(rolling_cv[,c(1:2)], type="l", col=c("grey45","steelblue"), bty="n")
550/2
275+165
440
550-440
tempdata <- data.frame(matrix(0,3,4))
colnames(tempdata)<-c("UID","TestR","Capture.Year","entry")
tempdata <- data.frame(UID, TestR , Capture.Year, entry)
tempdata$UID <- c(1297, 1297, 1297)
tempdata$TestR <- c("N","N","P")
tempdata$Capture.Year<-c(1991,1993,1997)
tempdata$entry<-c(1990,NA,NA)
tempdata
355*6
15000-2130
12870-5500
7370-2000
5370-2000
279*6
2130-1674
75*10
750+500
3370-1250
setwd("~/Repos/ecocast_compare/code")
##  R script to fit a population growth model for YNP,
##  forecast 10 new years, and partition the forecast variance.
##
##  Based on Dietze et al. (forthcoming)
##
##  Author:       Andrew Tredennick (atredenn@gmail.com)
##  Date created: October 19, 2016
##
rm(list=ls(all.names = TRUE))
####
####  Load libraries
####
library(ggplot2)
library(ggthemes)
library(gridExtra)
library(reshape2)
library(plyr)
library(rjags)
library(coda)
# library(devtools)
# install_github("atredennick/ecoforecastR") # get latest version
library(ecoforecastR)
####
####  Set Up My Plotting Theme -------------------------------------------------
####
my_theme <- theme_bw()+
theme(panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.grid.minor.y = element_blank(),
panel.grid.major.y = element_line(color="white"),
panel.background   = element_rect(fill = "#EFEFEF"),
axis.text          = element_text(size=10, color="grey35", family = "Arial Narrow"),
axis.title         = element_text(size=12, family = "Arial Narrow", face = "bold"),
panel.border       = element_blank(),
axis.line.x        = element_line(color="black"),
axis.line.y        = element_line(color="black"))
####
####  Load Data ----------------------------------------------------------------
####
bison_raw <- read.csv("../data/YNP_bison_population_size.csv", row.names = 1)
bison_dat <- bison_raw[which(!is.na(bison_raw$count.sd)),2:ncol(bison_raw)]
####
####  JAGS State-Space Model ---------------------------------------------------
####
my_model <- "
model{
#### Variance Priors
tau_proc ~ dgamma(0.0001, 0.0001)
sigma_proc <- 1/sqrt(tau_proc)
#### Fixed Effects Priors
r ~ dunif(0,5)
K ~ dunif(1,10000)
#### Initial Conditions
N0 ~ dunif(1,1000)
Nmed[1] <- log(max(1, N0 + r * N0 * (1 - N0 / K)))
N[1] ~ dlnorm(Nmed[1], tau_proc)
#### Process Model
for(t in 2:npreds){
Nmed[t] <- log(max(1, N[t-1] + r * N[t-1] * (1 - N[t-1] / K)))
N[t] ~ dlnorm(Nmed[t], tau_proc)
}
#### Data Model
##  SD observations
for(t in 1:n){
var_obs[t] <- sd_obs[t]*sd_obs[t]
shape[t] <- N[t]*N[t]/var_obs[t]
rate[t] <- N[t]/var_obs[t]
lambda[t] ~ dgamma(shape[t], rate[t])
Nobs[t] ~ dpois(lambda[t])
}
}"
####
####  Fit Bison Forecasting Model ----------------------------------------------
####
##  Prepare data list
mydat         <- list(Nobs = round(bison_dat$count.mean),
n = nrow(bison_dat),
sd_obs = bison_dat$count.sd,
npreds = nrow(bison_dat)+10)
out_variables <- c("r","K","sigma_proc","N")
##  Send to JAGS
mc3     <- jags.model(file=textConnection(my_model), data=mydat, n.chains=3)
update(mc3, n.iter = 10000)
mc3.out <- coda.samples(model=mc3, variable.names=out_variables, n.iter=50000)
## Split output
out          <- list(params=NULL, predict=NULL, model=my_model,data=mydat)
mfit         <- as.matrix(mc3.out,chains=TRUE)
pred.cols    <- union(grep("N[",colnames(mfit),fixed=TRUE),grep("Nmed[",colnames(mfit),fixed=TRUE))
chain.col    <- which(colnames(mfit)=="CHAIN")
out$predict  <- mat2mcmc.list(mfit[,c(chain.col,pred.cols)])
out$params   <- mat2mcmc.list(mfit[,-pred.cols])
fitted_model <- out
## Collate predictions
predictions        <- rbind(fitted_model$predict[[1]],
fitted_model$predict[[2]],
fitted_model$predict[[3]])
median_predictions <- apply(predictions, MARGIN = 2, FUN = "median")
upper_predictions  <- apply(predictions, MARGIN = 2, FUN = function(x){quantile(x, probs = 0.975)})
lower_predictions  <- apply(predictions, MARGIN = 2, FUN = function(x){quantile(x, probs = 0.025)})
prediction_df      <- data.frame(year = c(bison_dat$year, (max(bison_dat$year)+1):(max(bison_dat$year)+10)),
observation = c(bison_dat$count.mean,rep(NA,10)),
upper_observation = c(bison_dat$count.mean+bison_dat$count.sd,rep(NA,10)),
lower_observation = c(bison_dat$count.mean-bison_dat$count.sd,rep(NA,10)),
median_prediction = median_predictions,
upper_prediction = upper_predictions,
lower_prediction = lower_predictions)
##  Check parameter chains for convergence and mixing
# plot(fitted_model$params)
# gelman.diag(fitted_model$params)
# heidel.diag(fitted_model$params)
####
####  Plot the calibration data and predictions
####
pred_color <- "#CF4C26"
obs_color  <- "#0A9AB8"
ggplot(prediction_df, aes(x=year))+
geom_ribbon(aes(ymax=upper_prediction, ymin=lower_prediction), fill=pred_color, color=NA, alpha=0.2)+
geom_line(aes(y=median_prediction), color=pred_color)+
geom_errorbar(aes(ymin=lower_observation, ymax=upper_observation), width=0.5, color=obs_color, size=0.2)+
geom_point(aes(y=observation), color=obs_color, size=0.5)+
geom_vline(aes(xintercept=max(bison_dat$year)), linetype=2,color="grey55")+
ylab("Number of bison")+
xlab("Year")+
my_theme
