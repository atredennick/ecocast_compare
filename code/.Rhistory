mu[t]   <- zlog[t-1] + r + b*(zlog[t-1]) + b1*x[t]
zlog[t] ~ dnorm(mu[t], tau_proc)
z[t]    <- exp(zlog[t]) # back transform to arithmetic scale
}
#### Data Model
for(j in 2:n){
p[j]     <- eta/(eta + z[j]) # calculate NB centrality parameter
Nobs[j]  ~ dnegbin(p[j], eta) # NB likelihood
#Nobs[j] ~ dnorm(z[j], tau_obs[j])
}
####  Derived Quantities for Model Evaluation
for(i in 1:n){
# For autocorrelation test
epsilon.obs[i] <- Nobs[i] - z[i]
# Simulate new data
p2[i]        <- eta/(eta + z[i])
Nnew [i]     ~ dnegbin(p2[i], eta)
#Nnew[i] ~ dnorm(z[i], tau_obs[i])
sqerr[i]     <- ((Nobs[i] - z[i])^2)/Nobs[i]
sqerr_new[i] <- ((Nnew[i] - z[i])^2)/Nnew[i]
}
fit     <- sum(sqerr[])
fit.new <- sum(sqerr_new[])
pvalue  <- step(fit.new-fit)
}"
####
####  Fit Bison Forecasting Model ----------------------------------------------
####
##  For years without observation error, set to max observed standard deviation
na_sds                       <- which(is.na(bison_dat$count.sd)==T)
bison_dat[na_sds,"count.sd"] <- max(bison_dat$count.sd, na.rm=T)
##  Split into training and validation sets
training_dat   <- filter(bison_dat, set == "training")
validation_dat <- filter(bison_dat, set == "validation")
##  Set up SWE knowns (2011-2017), relative to scaling of observations
ppt_mean     <- mean(training_dat$ppt_in)
ppt_sd       <- sd(training_dat$ppt_in)
forecast_ppt <- precip_dat %>%
filter(year %in% validation_dat$year) %>%
pull(ppt_in)
scl_fut_ppt  <- (forecast_ppt - ppt_mean) / ppt_sd
##  Set initial values for unkown parameters
inits <- list(
list(sigma_proc = 0.01,
r = 0.05,
b = -0.001,
b1 = -0.5),
list(sigma_proc = 0.3,
r = 0.4,
b = -0.1,
b1 = -0.01),
list(sigma_proc = 0.1,
r = 0.7,
b = -0.00001,
b1 = -0.2)
)
####
####  FIT AND FORECAST WITH KNOWN JAN PPT --------------------------------------
####
##  Prepare data list
mydat <- list(Nobs    = round(training_dat$count.mean), # mean counts
n       = nrow(training_dat), # number of observations
tau_obs = 1/training_dat$count.sd^2, # transform s.d. to precision
x       = c(as.numeric(scale(training_dat$ppt_in)),scl_fut_ppt), # snow depth, plus forecast years
npreds  = nrow(training_dat)+nrow(validation_dat)) # number of total predictions (obs + forecast)
##  Random variables to collect
out_variables <- c("r", "b", "b1", "sigma_proc", "z", "pvalue", "fit", "fit.new")
##  Send to JAGS
mc3     <- jags.model(file = textConnection(my_model),
data = mydat,
n.chains = length(inits),
n.adapt = 5000,
inits = inits)
update(mc3, n.iter = 10000)
mc3.out <- coda.samples(model=mc3,
variable.names=out_variables,
n.iter=10000)
## Split output
out          <- list(params=NULL, predict=NULL)
mfit         <- as.matrix(mc3.out,chains=TRUE)
pred.cols    <- union(grep("z[",colnames(mfit),fixed=TRUE),grep("mu[",colnames(mfit),fixed=TRUE))
chain.col    <- which(colnames(mfit)=="CHAIN")
out$predict  <- mat2mcmc.list(mfit[,c(chain.col,pred.cols)])
out$params   <- mat2mcmc.list(mfit[,-pred.cols])
fitted_model <- out
## Collate predictions
predictions        <- rbind(fitted_model$predict[[1]],
fitted_model$predict[[2]],
fitted_model$predict[[3]])
median_predictions <- apply(predictions, MARGIN = 2, FUN = "median")
upper_predictions  <- apply(predictions, MARGIN = 2, FUN = function(x){quantile(x, probs = 0.975)})
lower_predictions  <- apply(predictions, MARGIN = 2, FUN = function(x){quantile(x, probs = 0.025)})
prediction_df      <- data.frame(year = bison_dat$year,
set = bison_dat$set,
observation = bison_dat$count.mean,
upper_observation = bison_dat$count.mean+bison_dat$count.sd,
lower_observation = bison_dat$count.mean-bison_dat$count.sd,
median_prediction = median_predictions,
upper_prediction = upper_predictions,
lower_prediction = lower_predictions)
####
####  PLOT DATA AND POSTERIOR PREDICTIONS --------------------------------------
####
pred_color <- "#CF4C26"
obs_color  <- "#278DAF"
pred_color <- "black"
obs_color  <- "black"
calibration_plot <- ggplot(prediction_df, aes(x=year))+
geom_ribbon(aes(ymax=upper_prediction, ymin=lower_prediction),
fill=pred_color,
color=NA,
alpha=0.2)+
geom_line(aes(y=median_prediction), color=pred_color, size = 0.2)+
geom_errorbar(data = filter(prediction_df, year <2011), aes(x = year, ymin=lower_observation, ymax=upper_observation),
width=0.5,
color=obs_color,
size=0.2)+
geom_point(data = filter(prediction_df, year <2011), aes(x = year, y=observation), color=obs_color, size=0.5)+
geom_vline(aes(xintercept=2010), linetype=2,color="grey55")+
# geom_col(data = bison_dat, aes(x = year, y = wint.removal), color = "grey55", fill = "grey55", width = 0.3)+
scale_y_continuous(breaks = seq(0,15000,2500))+
# scale_x_continuous(breaks = seq(1970,2015,5))+
ylab("Number of bison")+
xlab("Year")+
theme_few()
####
####  SET UP GCM PROJECTION MATRIX ---------------------------------------------
####
# Set up column names for GCM projection file
col_names <- c("year",
"month",
"day",
as.character(as.data.frame(read.table("../data/CMIP_YNP/bcca5/COLS_pr.txt"))[,1])
)
# Read in GCM projections and format as matrix
gcm_precip <- read_csv("../data/CMIP_YNP/bcca5/pr.csv", col_names = col_names) %>%
gather(key = model, value = ppt, -year, -month, -day) %>%
separate(model, into = c("model_name", "rep", "scenario"), sep = "[.]") %>%
group_by(year, month, model_name, scenario) %>%
summarise(total_ppt_mm = sum(ppt),
total_ppt_in = total_ppt_mm*0.0393701) %>%
ungroup() %>%
dplyr::filter(month == 1) %>%
dplyr::filter(year %in% c(2011,2012,2013,2014,2015,2016,2017)) %>%
dplyr::select(model_name, scenario, year, month, total_ppt_mm, total_ppt_in) %>%
dplyr::arrange(model_name, scenario, year, month) %>%
dplyr::mutate(stdzd_precip = (total_ppt_in-ppt_mean) / ppt_sd) %>%
dplyr::mutate(model_rcp = paste(model_name, scenario,"::")) %>%
dplyr::select(model_rcp, year, stdzd_precip) %>%
spread(model_rcp, stdzd_precip)
####
####  PARTITION FORECAST UNCERTAINTY -------------------------------------------
####
##  Function for the ecological process (Gompertz population growth)
iterate_process <- function(Nnow, xnow, r, b, b1, sd_proc) {
mu <- log(Nnow) + r + b*log(Nnow) + b1*xnow # determinstic process; log scale
zlog <- rnorm(length(mu), mu, sd_proc) # stochastic process; log scale
N <- exp(zlog) # back transform to arithmetic scale
}
##  Initial condition uncertainty: make forecasts from all MCMC iterations of
##    the final year, but use mean parameter values and no process error.
forecast_steps <- 7
num_iters      <- 1000
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
param_summary  <- summary(fitted_model$params)$quantile
r              <- param_summary[6,3]
b              <- param_summary[1,3]
b1             <- param_summary[2,3]
sd_proc        <- param_summary[7,3]
z              <- scl_fut_ppt
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
for(t in 1:forecast_steps){
x <- iterate_process(Nnow = x, xnow = z[t], r, b, b1, sd_proc = 0)
forecasts[,t] <- x
}
varI <- apply(forecasts,2,var)
##  Initial conditions and parameter uncertainty
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
params         <- as.matrix(fitted_model$params)
sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
b              <- params[sample_params,"b"]
b1             <- params[sample_params,"b1"]
sd_proc        <- param_summary[7,3]
z              <- scl_fut_ppt
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
for(t in 1:forecast_steps){
x <- iterate_process(Nnow = x, xnow = z[t], r, b, b1, sd_proc = 0)
forecasts[,t] <- x
}
varIP <- apply(forecasts,2,var)
##  Initial conditions, parameter, and driver uncertainty
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
params         <- as.matrix(fitted_model$params)
sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
b              <- params[sample_params,"b"]
b1             <- params[sample_params,"b1"]
sd_proc        <- params[sample_params,"sigma_proc"]
zsamps         <- sample(x = ncol(gcm_precip[2:ncol(gcm_precip)]), size = num_iters, replace = TRUE)
z              <- as.matrix(gcm_precip[2:ncol(gcm_precip)])
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
for(t in 1:forecast_steps){
x <- iterate_process(Nnow = x, xnow = as.numeric(z[t,zsamps]), r, b, b1, sd_proc = 0)
forecasts[,t] <- x
}
varIPD <- apply(forecasts,2,var)
##  Initial conditions, parameter, driver, and process uncertainty
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
params         <- as.matrix(fitted_model$params)
sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
b              <- params[sample_params,"b"]
b1             <- params[sample_params,"b1"]
sd_proc        <- params[sample_params,"sigma_proc"]
zsamps         <- sample(x = ncol(gcm_precip[2:ncol(gcm_precip)]), size = num_iters, replace = TRUE)
z              <- as.matrix(gcm_precip[2:ncol(gcm_precip)])
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
for(t in 1:forecast_steps){
x <- iterate_process(Nnow = x, xnow = as.numeric(z[t,zsamps]), r, b, b1, sd_proc = sd_proc)
forecasts[,t] <- x
}
varIPDE <- apply(forecasts,2,var)
V.pred.sim     <- rbind(varIPDE,varIPD,varIP,varI)
V.pred.sim.rel <- apply(V.pred.sim,2,function(x) {x/max(x)})
V.pred.sim.rel
var_rel_preds <- as.data.frame(t(V.pred.sim.rel*100))
var_rel_preds$x <- 1:nrow(var_rel_preds)
my_cols <- c("#0A4D5B", "#139AB8", "#39B181","grey")
variance_plot <- ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
variance_plot
var_rel_preds
nrow(bison_dat)
nrow(training_dat)
source('~/Repos/ecocast_compare/code/bison_forecast.R')
variance_plot
my_cols <- c("black", "grey25", "grey50","grey75")
variance_plot <- ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
variance_plot
ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"),
expand = c(0, 0))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"),
expand = c(0, 0))+
theme_few()
ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
calibration_plot
variance_plot
####
####  COMBINE PLOTS AND SAVE ---------------------------------------------------
####
suppressWarnings( # ignore warning about missing values, we know they are missing
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "auto")
)
library(cowplot)
####
####  COMBINE PLOTS AND SAVE ---------------------------------------------------
####
suppressWarnings( # ignore warning about missing values, we know they are missing
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "auto")
)
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "auto")
ggsave(filename = "../figures/bison_combined.png",
width = 4,
height = 6,
units = "in",
dpi =120)
my_cols <- c("black", "grey35", "grey60","grey85")
variance_plot <- ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
####
####  COMBINE PLOTS AND SAVE ---------------------------------------------------
####
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "auto")
ggsave(filename = "../figures/bison_combined.png",
width = 4,
height = 6,
units = "in",
dpi =120)
my_cols <- c("black", "grey55", "grey70","grey90")
variance_plot <- ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=varI, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=varIP, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=varIPD, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
####
####  COMBINE PLOTS AND SAVE ---------------------------------------------------
####
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "auto")
ggsave(filename = "../figures/bison_combined.png",
width = 4,
height = 6,
units = "in",
dpi =120)
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "auto")
ggsave(filename = "../figures/bison_combined.png",
width = 4,
height = 6,
units = "in",
dpi =200)
####
####  COMBINE PLOTS AND SAVE ---------------------------------------------------
####
plot_grid(calibration_plot, variance_plot, nrow = 2, labels = "AUTO")
ggsave(filename = "../figures/bison_combined.png",
width = 4,
height = 6,
units = "in",
dpi =200)
params[sample_params,"r"]
params[sample_params,"b"]
params[sample_params,"b1"]
hist(b1)
hist(b)
param_summary
source('~/Repos/ecocast_compare/code/bison_forecast.R')
V.pred.sim.rel
varIPDE
####
####  PLOT THE FORECASTING UNCERTAINTY PARTITION -------------------------------
####
var_rel_preds <- as.data.frame(t(V.pred.sim.rel*100))
var_rel_preds
##  Initial conditions, parameter, driver, and process uncertainty
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
params         <- as.matrix(fitted_model$params)
# sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
b              <- params[sample_params,"b"]
b1             <- params[sample_params,"b1"]
sd_proc        <- params[sample_params,"sigma_proc"]
zsamps         <- sample(x = ncol(gcm_precip[2:ncol(gcm_precip)]), size = num_iters, replace = TRUE)
z              <- as.matrix(gcm_precip[2:ncol(gcm_precip)])
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
for(t in 1:forecast_steps){
x <- iterate_process(Nnow = x, xnow = as.numeric(z[t,zsamps]), r, b, b1, sd_proc = sd_proc)
forecasts[,t] <- x
}
varIPDE <- apply(forecasts,2,var)
varIPDE
varIPD
sd_proc
param_summary
param_summary[7,3]
##  Initial conditions, parameter, driver, and process uncertainty
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
params         <- as.matrix(fitted_model$params)
# sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
b              <- params[sample_params,"b"]
b1             <- params[sample_params,"b1"]
sd_proc        <- param_summary[7,3]
zsamps         <- sample(x = ncol(gcm_precip[2:ncol(gcm_precip)]), size = num_iters, replace = TRUE)
z              <- as.matrix(gcm_precip[2:ncol(gcm_precip)])
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
for(t in 1:forecast_steps){
x <- iterate_process(Nnow = x, xnow = as.numeric(z[t,zsamps]), r, b, b1, sd_proc = sd_proc)
forecasts[,t] <- x
}
varIPDE <- apply(forecasts,2,var)
varIPDE
V.pred.sim     <- rbind(varIPDE,varIPD,varIP,varI)
V.pred.sim.rel <- apply(V.pred.sim,2,function(x) {x/max(x)})
V.pred.sim.rel
##  Initial conditions, parameter, and driver uncertainty
x              <- sample(predictions[,nrow(bison_dat)], num_iters, replace = TRUE)
params         <- as.matrix(fitted_model$params)
# sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
b              <- params[sample_params,"b"]
b1             <- params[sample_params,"b1"]
sd_proc        <- params[sample_params,"sigma_proc"]
zsamps         <- sample(x = ncol(gcm_precip[2:ncol(gcm_precip)]), size = num_iters, replace = TRUE)
z              <- as.matrix(gcm_precip[2:ncol(gcm_precip)])
forecasts      <- matrix(data = NA, nrow = num_iters, ncol = forecast_steps)
t = 1
Nnow = x, xnow = as.numeric(z[t,zsamps]), r, b, b1, sd_proc = 0
Nnow = x
xnow = as.numeric(z[t,zsamps])
sd_proc = 0
mu <- log(Nnow) + r + b*log(Nnow) + b1*xnow # determinstic process; log scale
my
mu
hist(mu)
zlog <- rnorm(length(mu), mu, sd_proc) # stochastic process; log scale
hist(zlog)
N <- exp(zlog) # back transform to arithmetic scale
hist(N)
sd_proc
sd_proc        <- param_summary[7,3]
mu <- log(Nnow) + r + b*log(Nnow) + b1*xnow # determinstic process; log scale
hist(mu)
zlog <- rnorm(length(mu), mu, sd_proc) # stochastic process; log scale
hist(zlog)
source('~/Repos/ecocast_compare/code/bison_forecast.R')
V.pred.sim.rel
ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
geom_ribbon(aes(ymin=0, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=0, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=0, ymax=varIPDE), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varIPDE), fill=my_cols[1])+
geom_ribbon(aes(ymin=0, ymax=varIPD), fill=my_cols[2])+
geom_ribbon(aes(ymin=0, ymax=varIP), fill=my_cols[3])+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[4])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
ggplot(data=var_rel_preds, aes(x=x))+
geom_ribbon(aes(ymin=0, ymax=varIPDE), fill=my_cols[4])+
geom_ribbon(aes(ymin=0, ymax=varIPD), fill=my_cols[3])+
geom_ribbon(aes(ymin=0, ymax=varIP), fill=my_cols[2])+
geom_ribbon(aes(ymin=0, ymax=varI), fill=my_cols[1])+
ylab("Percent of uncertainty")+
xlab("Forecast steps")+
scale_x_continuous(breaks=seq(1,forecast_steps,by=1),
labels=paste(seq(1,forecast_steps,by=1), "yrs"))+
scale_y_continuous(labels=paste0(seq(0,100,25),"%"))+
theme_few()
r              <- params[sample_params,"r"]
hist(r)
# sample_params  <- sample.int(nrow(params), size = num_iters, replace = TRUE)
r              <- params[sample_params,"r"]
hist(r)
head(params)
hist(params$r)
hist(params[,"r"])
scl_fut_ppt
source('~/Repos/ecocast_compare/code/bison_forecast.R', echo=TRUE)
V.pred.sim.rel
source('~/Repos/ecocast_compare/code/bison_forecast.R', echo=TRUE)
source('~/Repos/ecocast_compare/code/bison_forecast.R', echo=TRUE)
fitted_mode
dim(x = fitted_model)
fitted_model$params
source('~/Repos/ecocast_compare/code/bison_forecast.R', echo=TRUE)
source('~/Repos/ecocast_compare/code/bison_forecast.R', echo=TRUE)
source('~/Repos/ecocast_compare/code/bison_forecast.R', echo=TRUE)
param_summary
